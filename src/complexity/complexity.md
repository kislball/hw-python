# Алгоритм поиска количества правильных расстановок ферзей
Очевидно, что на одной строке может стоять лишь один ферзь. Значит для правильных расстановок достаточно хранить лишь колонки ферзей.

## Наивный(переборный) алгоритм
Наивный алгоритм перепроверяет всех ферзей попарно( $O(N^2)$ ) для каждой перестановки номеров колонок, которых всего $N!$.

Итого: сложность алгоритма $O(N^2 * N!)$.

## Рекурсивный алгоритм
Рекурсивный алгоритм проверяет все перестановки добавляя по одной строчке за раз, но при этом отбрасывает те, которые очевидно неправильные(ещё не все ферзи расположены, но уже есть конфликты).

На каждой итерации в цикле `for` в функции `_solve` сложность составляет $O(row)$ . Поэтому, сложность одного вызова `_solve` - $O(N\*row)$.
Далее, заметим, что `_solve` вызывается для `row` от 1 до N. Таким образом итоговая сложность составляет $O(N*N!)$ .

## Лучший алгоритм
Можно оптимизировать проверку диагоналей. Заметим, что каждую строку атакуемые клетки "сдвигаются"(по диагоналям). Представим такие ряды клеток как одно число,
где каждый бит означает, атакуется ли клетка или нет. Можем использовать побитовые сдвиги диагоналей, а ряды оставим как есть.

#### Анализ сложности
Сложность одного вызова `_solve` составляет $O(row)$ , где $row$ - текущая строка. Функция `_solve` вызывается на всех $row$ от $1$ до $N$.
Значит итоговая сложность $O(N!)$ .

## Лучший алгоритм при определённых ограничениях
Можно заранее вычислить значение для некоторых N и выводить его за константное время.
Сложность: $O(1)$ .
